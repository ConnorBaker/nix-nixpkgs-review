{
  config,
  inputs,
  lib,
  ...
}:
let
  inherit (builtins)
    attrNames
    attrValues
    deepSeq
    isAttrs
    mapAttrs
    parallel
    tryEval
    ;

  inherit (lib)
    genAttrs
    isDerivation
    mergeAttrsList
    recursiveUpdate
    showAttrPath
    zipListsWith
    ;

  withDup = f: a: f a a;

  /**
    Creates a report from a derivation given the attribute path prefix, attribute name, and derivation.
  */
  mkReport = prefix: name: drv: {
    inherit (drv)
      name
      system
      # meta
      ;

    attrPath = prefix ++ [ name ];

    ${if drv ? pname then "pname" else null} = drv.pname;
    ${if drv ? version then "version" else null} = drv.version;

    outputName = drv.outputName or "out";
    outputs = genAttrs (drv.outputs or [ "out" ]) (output: drv.${output}.outPath);
  };

  tryMkReport =
    prefix: name: value:
    (tryEval (
      withDup deepSeq (
        # 1. value is an attribute set
        if isAttrs value then
          # 1a. value is a derivation, we want to return the report
          if isDerivation value then
            mkReport prefix name value
          # 1b. value is an attribute set but not a derivation, so either we want to recurse into it or we don't
          else
            value.recurseForDerivations or false
        # 2. value is not an attribute set, we want to ignore it, return false
        else
          false
      )
    )).value;

  mkReports =
    let
      go =
        prefix: cursor:
        mergeAttrsList (
          # withDup parallel (
          zipListsWith (
            name: value:
            let
              maybeReport = tryMkReport prefix name value;
            in
            # Case where maybeReport is a report
            if isAttrs maybeReport then
              { ${showAttrPath maybeReport.attrPath} = maybeReport; }
            # Case where maybeReport is true, recurse
            else if maybeReport then
              go (prefix ++ [ name ]) value
            # Case where maybeReport is false, ignore
            else
              { }
          ) (attrNames cursor) (attrValues cursor)
          # )
        );
    in
    go [ ];
in
{
  # NOTE: Nix eval doesn't cache; only nix build and a few others do.
  flake.eval = genAttrs config.systems (
    system:
    mapAttrs
      (
        _: nixpkgsArgs:
        mkReports (
          import inputs.nixpkgs (
            recursiveUpdate {
              inherit system;
              # NOTE: Nixpkgs allows aliases by default which prints a bunch of evaluation warnings.
              config.allowAliases = false;
            } nixpkgsArgs
          )
          // {
            # See: https://github.com/NixOS/nixpkgs/pull/447555
            tests = { };
          }
        ).python313Packages
      )
      {
        pkgs = { };

        pkgsWithUnfree = {
          config.allowUnfree = true;
        };

        pkgsWithUnfreeCuda = {
          config = {
            allowUnfree = true;
            cudaSupport = true;
          };
        };
      }
  );
}
